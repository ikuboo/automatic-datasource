

package com.jd.auction.common.automatic.preparedstatement;

import com.google.common.base.Preconditions;
import com.jd.auction.common.automatic.connection.MasterSlaveConnection;
import com.jd.auction.common.automatic.connection.NamedConnection;
import com.jd.auction.common.automatic.constant.SQLType;
import com.jd.auction.common.automatic.datasouce.NamedDataSource;
import com.jd.auction.common.automatic.monitor.DataSourceStateJudge;
import com.jd.auction.common.automatic.parsing.SQLJudgeEngine;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;


public final class MasterSlavePreparedStatement extends AbstractMasterSlavePreparedStatementAdapter {

    private final MasterSlaveConnection masterSlaveConnection;

    private final PreparedStatement currentPreparedStatements;
    private final NamedConnection namedConnection;

    public MasterSlavePreparedStatement(final MasterSlaveConnection masterSlaveConnection, final String sql) throws SQLException {
        this(masterSlaveConnection, sql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY, ResultSet.HOLD_CURSORS_OVER_COMMIT);
    }

    public MasterSlavePreparedStatement(final MasterSlaveConnection masterSlaveConnection, final String sql, final int resultSetType, final int resultSetConcurrency) throws SQLException {
        this(masterSlaveConnection, sql, resultSetType, resultSetConcurrency, ResultSet.HOLD_CURSORS_OVER_COMMIT);
    }

    public MasterSlavePreparedStatement(final MasterSlaveConnection masterSlaveConnection, final String sql, final int resultSetType, final int resultSetConcurrency, final int resultSetHoldability) throws SQLException {
        this.masterSlaveConnection = masterSlaveConnection;
        SQLType sqlType = new SQLJudgeEngine(sql).judgeSQLType();
        this.namedConnection = masterSlaveConnection.getConnection(sqlType);
        Connection connection = namedConnection.getConnection();
        PreparedStatement preparedStatement = connection.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
        this.currentPreparedStatements = preparedStatement;
    }

    public MasterSlavePreparedStatement(final MasterSlaveConnection masterSlaveConnection, final String sql, final int autoGeneratedKeys) throws SQLException {
        this.masterSlaveConnection = masterSlaveConnection;
        SQLType sqlType = new SQLJudgeEngine(sql).judgeSQLType();
        this.namedConnection = masterSlaveConnection.getConnection(sqlType);
        Connection connection = namedConnection.getConnection();
        PreparedStatement preparedStatement = connection.prepareStatement(sql, autoGeneratedKeys);
        this.currentPreparedStatements = preparedStatement;
    }

    public MasterSlavePreparedStatement(final MasterSlaveConnection masterSlaveConnection, final String sql, final int[] columnIndexes) throws SQLException {
        this.masterSlaveConnection = masterSlaveConnection;
        SQLType sqlType = new SQLJudgeEngine(sql).judgeSQLType();
        this.namedConnection = masterSlaveConnection.getConnection(sqlType);
        Connection connection = namedConnection.getConnection();
        PreparedStatement preparedStatement = connection.prepareStatement(sql, columnIndexes);
        this.currentPreparedStatements = preparedStatement;
    }

    public MasterSlavePreparedStatement(final MasterSlaveConnection masterSlaveConnection, final String sql, final String[] columnNames) throws SQLException {
        this.masterSlaveConnection = masterSlaveConnection;
        SQLType sqlType = new SQLJudgeEngine(sql).judgeSQLType();
        this.namedConnection = masterSlaveConnection.getConnection(sqlType);
        Connection connection = namedConnection.getConnection();
        PreparedStatement preparedStatement = connection.prepareStatement(sql, columnNames);
        this.currentPreparedStatements = preparedStatement;

    }

    @Override
    public ResultSet executeQuery() throws SQLException {
        Preconditions.checkArgument(currentPreparedStatements != null, "Cannot support executeQuery for DDL");
        try {
            return currentPreparedStatements.executeQuery();
        } catch (SQLException e) {
            DataSourceStateJudge.judgeSQLException(namedConnection, e);
            throw e;
        }
    }

    @Override
    public int executeUpdate() throws SQLException {
        try {
            return currentPreparedStatements.executeUpdate();
        } catch (SQLException e) {
            DataSourceStateJudge.judgeSQLException(namedConnection, e);
            throw e;
        }
    }

    @Override
    public boolean execute() throws SQLException {
        try {
            return currentPreparedStatements.execute();
        } catch (SQLException e) {
            DataSourceStateJudge.judgeSQLException(namedConnection, e);
            throw e;
        }
    }


    @Override
    public void clearBatch() throws SQLException {
        try {
            currentPreparedStatements.clearBatch();
        } catch (SQLException e) {
            DataSourceStateJudge.judgeSQLException(namedConnection, e);
            throw e;
        }
    }


    @Override
    public void addBatch() throws SQLException {
        try {
            currentPreparedStatements.addBatch();
        } catch (SQLException e) {
            DataSourceStateJudge.judgeSQLException(namedConnection, e);
            throw e;
        }
    }


    @Override
    public int[] executeBatch() throws SQLException {
        try {
            return currentPreparedStatements.executeBatch();
        } catch (SQLException e) {
            DataSourceStateJudge.judgeSQLException(namedConnection, e);
            throw e;
        }
    }


    @Override
    public ResultSet getResultSet() throws SQLException {
        try {
            return currentPreparedStatements.getResultSet();
        } catch (SQLException e) {
            DataSourceStateJudge.judgeSQLException(namedConnection, e);
            throw e;
        }
    }


    @Override
    public ResultSet getGeneratedKeys() throws SQLException {
        try {
            return currentPreparedStatements.getGeneratedKeys();
        } catch (SQLException e) {
            DataSourceStateJudge.judgeSQLException(namedConnection, e);
            throw e;
        }
    }


    @Override
    public int getResultSetHoldability() throws SQLException {
        try {
            return currentPreparedStatements.getResultSetHoldability();
        } catch (SQLException e) {
            DataSourceStateJudge.judgeSQLException(namedConnection, e);
            throw e;
        }
    }

    @Override
    public int getResultSetConcurrency() throws SQLException {
        try {
            return currentPreparedStatements.getResultSetConcurrency();
        } catch (SQLException e) {
            DataSourceStateJudge.judgeSQLException(namedConnection, e);
            throw e;
        }
    }

    @Override
    public int getResultSetType() throws SQLException {
        try {
            return currentPreparedStatements.getResultSetType();
        } catch (SQLException e) {
            DataSourceStateJudge.judgeSQLException(namedConnection, e);
            throw e;
        }
    }

    @Override
    public MasterSlaveConnection getConnection() {
        return masterSlaveConnection;
    }

    @Override
    public PreparedStatement getCurrentStatements() {
        return currentPreparedStatements;
    }
}
